<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pandas_profiling.utils.dataframe API documentation</title>
<meta name="description" content="Utils for pandas DataFrames." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandas_profiling.utils.dataframe</code></h1>
</header>
<section id="section-intro">
<p>Utils for pandas DataFrames.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utils for pandas DataFrames.&#34;&#34;&#34;
import re
import unicodedata
import warnings
from pathlib import Path

import joblib
import pandas as pd


def warn_read(extension):
    &#34;&#34;&#34;Warn the user when an extension is not supported.

    Args:
        extension: The extension that is not supported.
    &#34;&#34;&#34;
    warnings.warn(
        f&#34;&#34;&#34;There was an attempt to read a file with extension {extension}, we assume it to be in CSV format.
To prevent this warning from showing up, please rename the file to any of the extensions supported by pandas
(docs: https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html)
If you think this extension should be supported, please report this as an issue:
https://github.com/pandas-profiling/pandas-profiling/issues&#34;&#34;&#34;
    )


def is_supported_compression(file_extension: str) -&gt; bool:
    &#34;&#34;&#34;Determine if the given file extension indicates a compression format that pandas can handle automatically.

    Args:
        file_extension (str): the file extension to test

    Returns:
        bool: True if the extension indicates a compression format that pandas handles automatically and False otherwise

    Notes:
        Pandas can handle on the fly decompression from the following extensions: ‘.bz2’, ‘.gz’, ‘.zip’, or ‘.xz’
        (otherwise no decompression). If using ‘.zip’, the ZIP file must contain exactly one data file to be read in.
    &#34;&#34;&#34;
    return file_extension.lower() in [&#34;.bz2&#34;, &#34;.gz&#34;, &#34;.xz&#34;, &#34;.zip&#34;]


def remove_suffix(text: str, suffix: str) -&gt; str:
    &#34;&#34;&#34;Removes the given suffix from the given string.

    Args:
        text (str): the string to remove the suffix from
        suffix (str): the suffix to remove from the string

    Returns:
        str: the string with the suffix removed, if the string ends with the suffix, otherwise the unmodified string

    Notes:
        In python 3.9+, there is a built-in string method called removesuffix() that can serve this purpose.
    &#34;&#34;&#34;
    return text[: -len(suffix)] if suffix and text.endswith(suffix) else text


def uncompressed_extension(file_name: Path) -&gt; str:
    &#34;&#34;&#34;Returns the uncompressed extension of the given file name.

    Args:
        file_name (Path): the file name to get the uncompressed extension of

    Returns:
        str: the uncompressed extension, or the original extension if pandas doesn&#39;t handle it automatically
    &#34;&#34;&#34;
    extension = file_name.suffix.lower()
    return (
        Path(remove_suffix(str(file_name).lower(), extension)).suffix
        if is_supported_compression(extension)
        else extension
    )


def read_pandas(file_name: Path) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Read DataFrame based on the file extension. This function is used when the file is in a standard format.
    Various file types are supported (.csv, .json, .jsonl, .data, .tsv, .xls, .xlsx, .xpt, .sas7bdat, .parquet)

    Args:
        file_name: the file to read

    Returns:
        DataFrame

    Notes:
        This function is based on pandas IO tools:
        https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html
        https://pandas.pydata.org/pandas-docs/stable/reference/io.html

        This function is not intended to be flexible or complete. The main use case is to be able to read files without
        user input, which is currently used in the editor integration. For more advanced use cases, the user should load
        the DataFrame in code.
    &#34;&#34;&#34;
    extension = uncompressed_extension(file_name)
    if extension == &#34;.json&#34;:
        df = pd.read_json(str(file_name))
    elif extension == &#34;.jsonl&#34;:
        df = pd.read_json(str(file_name), lines=True)
    elif extension == &#34;.dta&#34;:
        df = pd.read_stata(str(file_name))
    elif extension == &#34;.tsv&#34;:
        df = pd.read_csv(str(file_name), sep=&#34;\t&#34;)
    elif extension in [&#34;.xls&#34;, &#34;.xlsx&#34;]:
        df = pd.read_excel(str(file_name))
    elif extension in [&#34;.hdf&#34;, &#34;.h5&#34;]:
        df = pd.read_hdf(str(file_name))
    elif extension in [&#34;.sas7bdat&#34;, &#34;.xpt&#34;]:
        df = pd.read_sas(str(file_name))
    elif extension == &#34;.parquet&#34;:
        df = pd.read_parquet(str(file_name))
    elif extension in [&#34;.pkl&#34;, &#34;.pickle&#34;]:
        df = pd.read_pickle(str(file_name))
    elif extension == &#34;.tar&#34;:
        raise ValueError(
            &#34;tar compression is not supported directly by pandas, please use the &#39;tarfile&#39; module&#34;
        )
    else:
        if extension != &#34;.csv&#34;:
            warn_read(extension)

        df = pd.read_csv(str(file_name))
    return df


def rename_index(df):
    &#34;&#34;&#34;If the DataFrame contains a column or index named `index`, this will produce errors. We rename the {index,column}
    to be `df_index`.

    Args:
        df: DataFrame to process.

    Returns:
        The DataFrame with {index,column} `index` replaced by `df_index`, unchanged if the DataFrame does not contain such a string.
    &#34;&#34;&#34;
    df.rename(columns={&#34;index&#34;: &#34;df_index&#34;}, inplace=True)

    if &#34;index&#34; in df.index.names:
        df.index.names = [x if x != &#34;index&#34; else &#34;df_index&#34; for x in df.index.names]
    return df


def expand_mixed(df: pd.DataFrame, types=None) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Expand non-nested lists, dicts and tuples in a DataFrame into columns with a prefix.

    Args:
        types: list of types to expand (Default: list, dict, tuple)
        df: DataFrame

    Returns:
        DataFrame with the dict values as series, identifier by the combination of the series and dict keys.

    Notes:
        TODO: allow for list expansion by duplicating rows.
        TODO: allow for expansion of nested data structures.
    &#34;&#34;&#34;
    if types is None:
        types = [list, dict, tuple]

    for column_name in df.columns:
        # All
        non_nested_enumeration = (
            df[column_name]
            .dropna()
            .map(lambda x: type(x) in types and not any(type(y) in types for y in x))
        )

        if non_nested_enumeration.all():
            # Expand and prefix
            expanded = pd.DataFrame(df[column_name].dropna().tolist())
            expanded = expanded.add_prefix(column_name + &#34;_&#34;)

            # Add recursion
            expanded = expand_mixed(expanded)

            # Drop te expanded
            df.drop(columns=[column_name], inplace=True)

            df = pd.concat([df, expanded], axis=1)
    return df


def hash_dataframe(df):
    &#34;&#34;&#34;Hash a DataFrame (wrapper around joblib.hash, might change in the future)

    Args:
        df: the DataFrame

    Returns:
        The DataFrame&#39;s hash
    &#34;&#34;&#34;
    return joblib.hash(df)


def slugify(value, allow_unicode=False):
    &#34;&#34;&#34;
    Taken from https://github.com/django/django/blob/master/django/utils/text.py
    Convert to ASCII if &#39;allow_unicode&#39; is False. Convert spaces or repeated
    dashes to single dashes. Remove characters that aren&#39;t alphanumerics,
    underscores, or hyphens. Convert to lowercase. Also strip leading and
    trailing whitespace, dashes, and underscores.
    &#34;&#34;&#34;
    value = str(value)
    if allow_unicode:
        value = unicodedata.normalize(&#34;NFKC&#34;, value)
    else:
        value = (
            unicodedata.normalize(&#34;NFKD&#34;, value)
            .encode(&#34;ascii&#34;, &#34;ignore&#34;)
            .decode(&#34;ascii&#34;)
        )
    value = re.sub(r&#34;[^\w\s-]&#34;, &#34;&#34;, value.lower())
    return re.sub(r&#34;[-\s]+&#34;, &#34;-&#34;, value).strip(&#34;-_&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pandas_profiling.utils.dataframe.expand_mixed"><code class="name flex">
<span>def <span class="ident">expand_mixed</span></span>(<span>df: pandas.core.frame.DataFrame, types=None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Expand non-nested lists, dicts and tuples in a DataFrame into columns with a prefix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>types</code></strong></dt>
<dd>list of types to expand (Default: list, dict, tuple)</dd>
<dt><strong><code>df</code></strong></dt>
<dd>DataFrame</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DataFrame with the dict values as series, identifier by the combination of the series and dict keys.</p>
<h2 id="notes">Notes</h2>
<p>TODO: allow for list expansion by duplicating rows.
TODO: allow for expansion of nested data structures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_mixed(df: pd.DataFrame, types=None) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Expand non-nested lists, dicts and tuples in a DataFrame into columns with a prefix.

    Args:
        types: list of types to expand (Default: list, dict, tuple)
        df: DataFrame

    Returns:
        DataFrame with the dict values as series, identifier by the combination of the series and dict keys.

    Notes:
        TODO: allow for list expansion by duplicating rows.
        TODO: allow for expansion of nested data structures.
    &#34;&#34;&#34;
    if types is None:
        types = [list, dict, tuple]

    for column_name in df.columns:
        # All
        non_nested_enumeration = (
            df[column_name]
            .dropna()
            .map(lambda x: type(x) in types and not any(type(y) in types for y in x))
        )

        if non_nested_enumeration.all():
            # Expand and prefix
            expanded = pd.DataFrame(df[column_name].dropna().tolist())
            expanded = expanded.add_prefix(column_name + &#34;_&#34;)

            # Add recursion
            expanded = expand_mixed(expanded)

            # Drop te expanded
            df.drop(columns=[column_name], inplace=True)

            df = pd.concat([df, expanded], axis=1)
    return df</code></pre>
</details>
</dd>
<dt id="pandas_profiling.utils.dataframe.hash_dataframe"><code class="name flex">
<span>def <span class="ident">hash_dataframe</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Hash a DataFrame (wrapper around joblib.hash, might change in the future)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>the DataFrame</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The DataFrame's hash</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash_dataframe(df):
    &#34;&#34;&#34;Hash a DataFrame (wrapper around joblib.hash, might change in the future)

    Args:
        df: the DataFrame

    Returns:
        The DataFrame&#39;s hash
    &#34;&#34;&#34;
    return joblib.hash(df)</code></pre>
</details>
</dd>
<dt id="pandas_profiling.utils.dataframe.is_supported_compression"><code class="name flex">
<span>def <span class="ident">is_supported_compression</span></span>(<span>file_extension: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if the given file extension indicates a compression format that pandas can handle automatically.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_extension</code></strong> :&ensp;<code>str</code></dt>
<dd>the file extension to test</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the extension indicates a compression format that pandas handles automatically and False otherwise</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Pandas can handle on the fly decompression from the following extensions: ‘.bz2’, ‘.gz’, ‘.zip’, or ‘.xz’
(otherwise no decompression). If using ‘.zip’, the ZIP file must contain exactly one data file to be read in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_supported_compression(file_extension: str) -&gt; bool:
    &#34;&#34;&#34;Determine if the given file extension indicates a compression format that pandas can handle automatically.

    Args:
        file_extension (str): the file extension to test

    Returns:
        bool: True if the extension indicates a compression format that pandas handles automatically and False otherwise

    Notes:
        Pandas can handle on the fly decompression from the following extensions: ‘.bz2’, ‘.gz’, ‘.zip’, or ‘.xz’
        (otherwise no decompression). If using ‘.zip’, the ZIP file must contain exactly one data file to be read in.
    &#34;&#34;&#34;
    return file_extension.lower() in [&#34;.bz2&#34;, &#34;.gz&#34;, &#34;.xz&#34;, &#34;.zip&#34;]</code></pre>
</details>
</dd>
<dt id="pandas_profiling.utils.dataframe.read_pandas"><code class="name flex">
<span>def <span class="ident">read_pandas</span></span>(<span>file_name: pathlib.Path) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Read DataFrame based on the file extension. This function is used when the file is in a standard format.
Various file types are supported (.csv, .json, .jsonl, .data, .tsv, .xls, .xlsx, .xpt, .sas7bdat, .parquet)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_name</code></strong></dt>
<dd>the file to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DataFrame</p>
<h2 id="notes">Notes</h2>
<p>This function is based on pandas IO tools:
<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html</a>
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/io.html">https://pandas.pydata.org/pandas-docs/stable/reference/io.html</a></p>
<p>This function is not intended to be flexible or complete. The main use case is to be able to read files without
user input, which is currently used in the editor integration. For more advanced use cases, the user should load
the DataFrame in code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_pandas(file_name: Path) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Read DataFrame based on the file extension. This function is used when the file is in a standard format.
    Various file types are supported (.csv, .json, .jsonl, .data, .tsv, .xls, .xlsx, .xpt, .sas7bdat, .parquet)

    Args:
        file_name: the file to read

    Returns:
        DataFrame

    Notes:
        This function is based on pandas IO tools:
        https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html
        https://pandas.pydata.org/pandas-docs/stable/reference/io.html

        This function is not intended to be flexible or complete. The main use case is to be able to read files without
        user input, which is currently used in the editor integration. For more advanced use cases, the user should load
        the DataFrame in code.
    &#34;&#34;&#34;
    extension = uncompressed_extension(file_name)
    if extension == &#34;.json&#34;:
        df = pd.read_json(str(file_name))
    elif extension == &#34;.jsonl&#34;:
        df = pd.read_json(str(file_name), lines=True)
    elif extension == &#34;.dta&#34;:
        df = pd.read_stata(str(file_name))
    elif extension == &#34;.tsv&#34;:
        df = pd.read_csv(str(file_name), sep=&#34;\t&#34;)
    elif extension in [&#34;.xls&#34;, &#34;.xlsx&#34;]:
        df = pd.read_excel(str(file_name))
    elif extension in [&#34;.hdf&#34;, &#34;.h5&#34;]:
        df = pd.read_hdf(str(file_name))
    elif extension in [&#34;.sas7bdat&#34;, &#34;.xpt&#34;]:
        df = pd.read_sas(str(file_name))
    elif extension == &#34;.parquet&#34;:
        df = pd.read_parquet(str(file_name))
    elif extension in [&#34;.pkl&#34;, &#34;.pickle&#34;]:
        df = pd.read_pickle(str(file_name))
    elif extension == &#34;.tar&#34;:
        raise ValueError(
            &#34;tar compression is not supported directly by pandas, please use the &#39;tarfile&#39; module&#34;
        )
    else:
        if extension != &#34;.csv&#34;:
            warn_read(extension)

        df = pd.read_csv(str(file_name))
    return df</code></pre>
</details>
</dd>
<dt id="pandas_profiling.utils.dataframe.remove_suffix"><code class="name flex">
<span>def <span class="ident">remove_suffix</span></span>(<span>text: str, suffix: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the given suffix from the given string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>the string to remove the suffix from</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>the suffix to remove from the string</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the string with the suffix removed, if the string ends with the suffix, otherwise the unmodified string</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In python 3.9+, there is a built-in string method called removesuffix() that can serve this purpose.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_suffix(text: str, suffix: str) -&gt; str:
    &#34;&#34;&#34;Removes the given suffix from the given string.

    Args:
        text (str): the string to remove the suffix from
        suffix (str): the suffix to remove from the string

    Returns:
        str: the string with the suffix removed, if the string ends with the suffix, otherwise the unmodified string

    Notes:
        In python 3.9+, there is a built-in string method called removesuffix() that can serve this purpose.
    &#34;&#34;&#34;
    return text[: -len(suffix)] if suffix and text.endswith(suffix) else text</code></pre>
</details>
</dd>
<dt id="pandas_profiling.utils.dataframe.rename_index"><code class="name flex">
<span>def <span class="ident">rename_index</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>If the DataFrame contains a column or index named <code>index</code>, this will produce errors. We rename the {index,column}
to be <code>df_index</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>DataFrame to process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The DataFrame with {index,column} <code>index</code> replaced by <code>df_index</code>, unchanged if the DataFrame does not contain such a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_index(df):
    &#34;&#34;&#34;If the DataFrame contains a column or index named `index`, this will produce errors. We rename the {index,column}
    to be `df_index`.

    Args:
        df: DataFrame to process.

    Returns:
        The DataFrame with {index,column} `index` replaced by `df_index`, unchanged if the DataFrame does not contain such a string.
    &#34;&#34;&#34;
    df.rename(columns={&#34;index&#34;: &#34;df_index&#34;}, inplace=True)

    if &#34;index&#34; in df.index.names:
        df.index.names = [x if x != &#34;index&#34; else &#34;df_index&#34; for x in df.index.names]
    return df</code></pre>
</details>
</dd>
<dt id="pandas_profiling.utils.dataframe.slugify"><code class="name flex">
<span>def <span class="ident">slugify</span></span>(<span>value, allow_unicode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Taken from <a href="https://github.com/django/django/blob/master/django/utils/text.py">https://github.com/django/django/blob/master/django/utils/text.py</a>
Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated
dashes to single dashes. Remove characters that aren't alphanumerics,
underscores, or hyphens. Convert to lowercase. Also strip leading and
trailing whitespace, dashes, and underscores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slugify(value, allow_unicode=False):
    &#34;&#34;&#34;
    Taken from https://github.com/django/django/blob/master/django/utils/text.py
    Convert to ASCII if &#39;allow_unicode&#39; is False. Convert spaces or repeated
    dashes to single dashes. Remove characters that aren&#39;t alphanumerics,
    underscores, or hyphens. Convert to lowercase. Also strip leading and
    trailing whitespace, dashes, and underscores.
    &#34;&#34;&#34;
    value = str(value)
    if allow_unicode:
        value = unicodedata.normalize(&#34;NFKC&#34;, value)
    else:
        value = (
            unicodedata.normalize(&#34;NFKD&#34;, value)
            .encode(&#34;ascii&#34;, &#34;ignore&#34;)
            .decode(&#34;ascii&#34;)
        )
    value = re.sub(r&#34;[^\w\s-]&#34;, &#34;&#34;, value.lower())
    return re.sub(r&#34;[-\s]+&#34;, &#34;-&#34;, value).strip(&#34;-_&#34;)</code></pre>
</details>
</dd>
<dt id="pandas_profiling.utils.dataframe.uncompressed_extension"><code class="name flex">
<span>def <span class="ident">uncompressed_extension</span></span>(<span>file_name: pathlib.Path) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the uncompressed extension of the given file name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>Path</code></dt>
<dd>the file name to get the uncompressed extension of</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the uncompressed extension, or the original extension if pandas doesn't handle it automatically</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uncompressed_extension(file_name: Path) -&gt; str:
    &#34;&#34;&#34;Returns the uncompressed extension of the given file name.

    Args:
        file_name (Path): the file name to get the uncompressed extension of

    Returns:
        str: the uncompressed extension, or the original extension if pandas doesn&#39;t handle it automatically
    &#34;&#34;&#34;
    extension = file_name.suffix.lower()
    return (
        Path(remove_suffix(str(file_name).lower(), extension)).suffix
        if is_supported_compression(extension)
        else extension
    )</code></pre>
</details>
</dd>
<dt id="pandas_profiling.utils.dataframe.warn_read"><code class="name flex">
<span>def <span class="ident">warn_read</span></span>(<span>extension)</span>
</code></dt>
<dd>
<div class="desc"><p>Warn the user when an extension is not supported.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension</code></strong></dt>
<dd>The extension that is not supported.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def warn_read(extension):
    &#34;&#34;&#34;Warn the user when an extension is not supported.

    Args:
        extension: The extension that is not supported.
    &#34;&#34;&#34;
    warnings.warn(
        f&#34;&#34;&#34;There was an attempt to read a file with extension {extension}, we assume it to be in CSV format.
To prevent this warning from showing up, please rename the file to any of the extensions supported by pandas
(docs: https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html)
If you think this extension should be supported, please report this as an issue:
https://github.com/pandas-profiling/pandas-profiling/issues&#34;&#34;&#34;
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandas_profiling.utils" href="index.html">pandas_profiling.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pandas_profiling.utils.dataframe.expand_mixed" href="#pandas_profiling.utils.dataframe.expand_mixed">expand_mixed</a></code></li>
<li><code><a title="pandas_profiling.utils.dataframe.hash_dataframe" href="#pandas_profiling.utils.dataframe.hash_dataframe">hash_dataframe</a></code></li>
<li><code><a title="pandas_profiling.utils.dataframe.is_supported_compression" href="#pandas_profiling.utils.dataframe.is_supported_compression">is_supported_compression</a></code></li>
<li><code><a title="pandas_profiling.utils.dataframe.read_pandas" href="#pandas_profiling.utils.dataframe.read_pandas">read_pandas</a></code></li>
<li><code><a title="pandas_profiling.utils.dataframe.remove_suffix" href="#pandas_profiling.utils.dataframe.remove_suffix">remove_suffix</a></code></li>
<li><code><a title="pandas_profiling.utils.dataframe.rename_index" href="#pandas_profiling.utils.dataframe.rename_index">rename_index</a></code></li>
<li><code><a title="pandas_profiling.utils.dataframe.slugify" href="#pandas_profiling.utils.dataframe.slugify">slugify</a></code></li>
<li><code><a title="pandas_profiling.utils.dataframe.uncompressed_extension" href="#pandas_profiling.utils.dataframe.uncompressed_extension">uncompressed_extension</a></code></li>
<li><code><a title="pandas_profiling.utils.dataframe.warn_read" href="#pandas_profiling.utils.dataframe.warn_read">warn_read</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>